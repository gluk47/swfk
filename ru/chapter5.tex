% !TeX encoding = UTF-8
% Use XeLaTeX to compile it
%
% Эта работа распространяется на условиях лицензии Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% Краткое описание лицензии есть тут: http://creativecommons.org/licenses/by-nc-sa/3.0/nz/deed.ru
% Полное — там же.
% Эту книгу можно невозбранно распространять и изменять, но только соблюдая следующие условия:
% сохраняя лицензию и не вводя дополнительных ограничений, бесплатно
% и указывая авторство как оригинальной части, так и изменённой.
% Автор оригинального английского текста — Jason R Briggs http://jasonrbriggs.com/
% Автор перевода — Егор Кочетов <Egor.Kochetoff@gmail.com>
%
% This work is licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 New Zealand License.
% To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/nz
% or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
%

\chapter{Снова и снова}\label{ch:againandagain}

Нет ничего хуже, чем делать одно и то же много раз подряд, одинаково и монотонно. Примерно поэтому родители могли когда-нибудь советовать тебе считать воображаемых овец, пока ты не уснёшь (а вовсе не потому, что эти шерстяные животные обладают магическими способностями усыплять). Всё дело в том, что повторять без конца одно и то же — скучно, и твоё сознание скоро сдастся и уступит место сну.

Программисты тоже не большие любители повторять одни и те же действия. От этого их тоже клонит в сон. Так что почти во всех языках программирования есть такая штука как \textit{цикл}\footnote{Некоторые языки обходятся без циклов, а некоторые — и без переменных. Но, как я и говорила, о других языках тут мы поговорить просто не успеем.}. В частности, \textit{цикл for}. И вот зачем. Допустим, тебе захочется 5 раз напечатать «Привет». Можно было бы сделать это так:
\begin{listing}
\begin{verbatim}
>>> print("Привет")
Привет
>>> print("Привет")
Привет
>>> print("Привет")
Привет
>>> print("Привет")
Привет
>>> print("Привет")
Привет
\end{verbatim}
\end{listing}

Но так писать очень утомительно.

Вместо того, чтобы повторять кучу раз одно и то же, можно использовать цикл \code{for} (не забудь про 4 пробела во второй строчке перед \code{print}):

\begin{verbatim}
>>> for x in range(0, 5):
...     print('Привет')
... 
Привет
Привет
Привет
Привет
Привет
\end{verbatim}

Функция \code{range}\index{функции!range} — быстрый способ создать список чисел от начального значения (включительно) до конечного (не включительно). Вот пример:

\begin{listing}
\begin{verbatim}
>>> print(list(range(10, 20)))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
\end{verbatim}
\end{listing}

И в нашем цикле \code{for} на самом деле строчка \code{for x in range(0, 5)} говорит Питону создать список чисел \code{[0, 1, 2, 3, 4]}, сохранить по очереди каждое из этих чисел в переменной \code{x} и выполнить для каждого значения этой переменной блок кода, написанный под \code{for}. Переменную \code{x} тоже можно использовать для печати:

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 5):
...     print('[%s] Привет' % x)
...
[0] Привет
[1] Привет
[2] Привет
[3] Привет
[4] Привет
\end{verbatim}
\end{listing}

Если явно записать то, что происходит в цикле \code{for}, то получится что-то такое:

\begin{listing}
\begin{verbatim}
x = 0
print('[%s] Привет' % x)
x = 1
print('[%s] Привет' % x)
x = 2
print('[%s] Привет' % x)
x = 3
print('[%s] Привет' % x)
x = 4
print('[%s] Привет' % x)
\end{verbatim}
\end{listing}

Так что цикл нас тут избавил от лишних восьми строк кода. И это невероятно полезно, потому что средний программист чуть более ленив, чем бегемот жарким днём, когда дело доходит до печатания кода. Хорошие программисты ненавидят делать одно и то же больше одного раза (и на то есть серьёзные причины\footnote{Например, если найдётся ошибка в каком-то коде, то исправить её нужно будет только один раз. Если один и тот же ошибочный код использовать несколько раз, то где-то ошибку точно забудут исправить.}), так что цикл — одна из самых полезных инструкций в языке программирования.

\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{Аккуратней с пробелами!}

Возможно, ты пытался запустить примеры из этой главы и в качестве результата получил только сообщение об ошибке вроде такого:

\begin{listing}
IndentationError: expected an indented block
\end{listing}

Такая ошибка значит, что в начале строки не хватает пробелов, хотя бы одного. Пробелы в начале строки в Питоне очень важны. Скоро мы о них поговорим подробнее…
}}}
\linebreak

Можно не ограничиваться функцией \code{range} для цикла \code{for}, можно использовать и другие списки (которые мы раньше создавали). Вот, например, список покупок:

\begin{listing}
\begin{verbatim}
>>> shopping_list = [ 'яиц', 'молока', 'сыра', 'сельдерея', 'масла', 'соды' ]
>>> for i in shopping_list:
...     print("Как бы не забыть купить %s" % i)
Как бы не забыть купить яиц
Как бы не забыть купить молока
Как бы не забыть купить сыра
Как бы не забыть купить сельдерея
Как бы не забыть купить масла
Как бы не забыть купить соды
\end{verbatim}
\end{listing}

Этот код значит «сохрани по очереди каждый из элементов списка в переменной \code{i} и выполни \code{print} для каждого из значений».

Опять же, если бы мы решили делать это без списка, то пришлось бы печатать что-нибудь такое:

\begin{listing}
\begin{verbatim}
>>> shopping_list = [ 'яиц', 'молока', 'сыра', 'сельдерея', 'масла', 'соды' ]
>>> print("Как бы не забыть купить %s" % shopping_list[0])
Как бы не забыть купить яиц
>>> print("Как бы не забыть купить %s" % shopping_list[1])
Как бы не забыть купить молока
>>> print("Как бы не забыть купить %s" % shopping_list[2])
Как бы не забыть купить сыра
>>> print("Как бы не забыть купить %s" % shopping_list[3])
Как бы не забыть купить сельдерея
>>> print("Как бы не забыть купить %s" % shopping_list[4])
Как бы не забыть купить масла
>>> print("Как бы не забыть купить %s" % shopping_list[5])
Как бы не забыть купить соды
\end{verbatim}
\end{listing}

Так что \code{for} снова спас нас от кууучи лишнего кода.

\section{Зачем нужны блоки программистам?}\index{блоки кода}

Чтобы делать их из кода.

Что же такое «блок кода»?

Блок кода — это несколько программных инструкций, объединённых вместе. Например, в примере с циклом \code{for} может захотеться не только печатать, что надо купить, но и как-нибудь покупать. Предположим, что есть функция \code{buy} для этого (на самом деле её пока нет). Тогда можно записать этот пример вот так:

\begin{verbatim}
>>> for i in shopping_list:
...     buy(i)
...     print(i)
\end{verbatim}

Печатать это в консоль не стоит и пытаться, потому что функции \code{buy} нету, и результатом будет только сообщение об ошибке. Зато тут есть настоящий блок кода, вот этот:

\begin{verbatim}
    buy(i)
    print(i)
\end{verbatim}

В Питоне пробельные символы\index{пробельные символы}, а именно символ табуляции (который получается, если нажать клавишу Tab\footnote{В консоли Питона этот способ не сработает, только в текстовом редакторе так получится.}) и символ пробела, очень важны. Код с одинаковым отступом от начала строки автоматически группируется в блоки.

\begin{listing}
\begin{verbatim}
	это блок 1
	это блок 1
	это блок 1
	    это блок 2
	    это блок 2
	    это блок 2
	это всё ещё блок 1
	это всё ещё блок 1
	    это блок 3
	    это блок 3
	        это блок 4
	        это блок 4
	        это блок 4
\end{verbatim}
\end{listing}

Единственное правило тут — что нужно использовать одно и то же количество пробелов в начале строк внутри всего блока. Вот так неправильно:

\begin{verbatim}
>>> for i in shopping_list:
...     buy(i)
...       print(i)
\end{verbatim}

Отступ второй строки здесь 4 пробела, а третьей строки — 6 пробелов, её начало сдвинуто ещё на 2 символа вправо. Такой код вызовет ошибку. Если уж блок начался с отступом в 4 пробела, то так он и должен продолжаться. А если хочется внутри блока поместить другой, то нужно будет использовать 8 пробелов (два раза по четыре) в начале строк этого внутреннего блока. Вот так правильно:

\begin{listing}
\begin{verbatim}
    вот первый блок кода
    вот первый блок кода
\end{verbatim}
\end{listing}

И вот блок кода, в который вложен ещё один. Все строчки в нём начинаются с 8 пробелов:

\begin{listing}
\begin{verbatim}
    вот первый блок кода
    вот первый блок кода
        вот второй блок кода
        вот второй блок кода
\end{verbatim}
\end{listing}

Зачем может захотеться вложить один блок кода в другой? Обычно это случается, когда второй блок зависит от первого. Например, если второй блок — тело цикла \code{for}. Строчка со словом \code{for} находится в первом блоке кода, а всё, что должно выполняться в цикле, нужно поместить во второй блок.

Если ты начинаешь блок в консоли Питона, то Питон продолжает этот блок до тех пор, пока ты не нажмёшь
Enter в пустой строке. Каждую строчку блока при этом Питон начинает с трёх точек.

Давай попробуем ввести в консоль пример. Напечатай туда код, написанный ниже, не забывая про 4 пробела в начале строк в блоке кода после \code{for}\footnote{Вообще, в консоли хватит и одного пробела. Для блока, вложенного в первый, — двух пробелов и так далее. 4 пробела используют в программах, которые сохраняют в файлы и которые потом люди будут читать ещё раз.}.

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     print(i * 3)
...
a
aaa
b
bbb
c
ccc
\end{verbatim}
\end{listing}

После второй строчки с \code{print} нужно нажать Enter на пустой строке — так Питон поймёт, что ты хочешь завершить блок. И напечатает всё, что просили.

Следующий пример вызовет ошибку:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...       print(i)
...
File “<stdin>”, line 3
  print(i)
  ^
IndentationError: unexpected indent
\end{verbatim}
\end{listing}

В начале второй строчки с командой \code{print} вместо четырёх пробелов шесть, что Питону крайне не нравится: отступы должны быть одинаковыми, какие бы они ни были.

\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{Запомни}

Если ты используешь четыре пробела, чтобы сделать отступ для одного из блоков кода, то все следующие блоки нужно тоже начинать с четырёх пробелов. Если же для отступов используются два пробела, то два и нужно использовать во всей программе. Большинство людей используют четыре пробела, чего я и тебе советую.
}}}

Вот пример чуть посложнее с двумя блоками кода:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     for j in mylist:
...         print(j)
...
\end{verbatim}
\end{listing}

Где в этом коде блоки и что он делает?..

Блоков два. Первый — часть первого цикла \code{for}:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)                #
...     for j in mylist:        #<-- все эти строки — это первый блок кода
...         print(j)            #<-- эта строка — тоже часть первого блока
...
\end{verbatim}
\end{listing}

Второй блок состоит из одной строки, выполняющейся во вложенном цикле \code{for}:

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     for j in mylist:
...         print(j)               #<-- вот эта строка — второй блок кода
...
\end{verbatim}
\end{listing}

Можешь ли ты понять, глядя на этот код, что он делает?

Он напечатает каждую из трёх букв из списка, но сколько раз? Если мы внимательно посмотрим на код, то, скорее всего, сможем ответить на этот вопрос. Мы знаем, что первый цикл \code{for} выполнится для каждой буквы один раз. Он напечатает эту букву, а потом запустит вложенный цикл. А вложенный цикл опять выполнится по разу для каждой буквы и просто её напечатает. Получается, что сначала на экране появится буква 'a', затем — по очереди буквы 'a', 'b', 'c'. Потом — буква 'b' и опять все три и потом — буква 'c'. Можешь ввести этот код в консоль Питона и собственноручно убедиться, что всё так и будет.

\begin{listing}
\begin{verbatim}
>>> mylist = [ 'a', 'b', 'c' ]
>>> for i in mylist:
...     print(i)
...     for j in mylist:
...         print(j)
... 
a
a
b
c
b
a
b
c
c
a
b
c
\end{verbatim}
\end{listing}

Кажется, я слышу вопрос, можно ли использовать циклы для чего-то немного более полезного, чем печать букв одной за одной? Можно, конечно, иначе бы и не стали циклы придумывать. Вспомни пример из второй главы, когда мы считали, сколько карманных денег накопится к концу года. Там тебе платили 5 рублей в неделю за домашние дела, 30 рублей в неделю за разнос газет, и ещё ты тратил 10 рублей в неделю.

К концу года копилась вот такая сумма:

\begin{listing}
\begin{verbatim}
>>> (5 + 30 - 10) * 52
\end{verbatim}
\end{listing}

\noindent
(5 рублей + 30 рублей − 10 рублей, и всё это умножить на 52 недели в году).

Может захотеться посмотреть, сколько денег накопится в каждую из недель года, чтобы прикинуть, насколько быстро удастся накопить на ту или иную вещь, и выбрать: на что копить, чтобы было не слишком долго (и сколько именно придётся копить). Этого можно добиться, как раз используя цикл for. Однако прежде всего надо сохранить все эти числа в переменные\footnote{В любых программах не принято использовать числа или строки просто так. Их сохраняют в переменные. Во-первых, так сразу видно, что значит число (если переменная названа понятно); во-вторых, его легко поменять всего в одном месте.}:

\begin{listing}
\begin{verbatim}
>>> chores = 5
>>> paper = 30
>>> spending = 10
\end{verbatim}
\end{listing}

Теперь исходный пример записывается так:

\begin{listing}
\begin{verbatim}
>>> (chores + paper - spending) * 52
1300
\end{verbatim}
\end{listing}

А увидеть, сколько денег накопится в каждую из недель, можно так:

\begin{listing}
\begin{verbatim}
1. >>> savings = 0
2. >>> for week in range(1, 53):
3. ...     savings = savings + chores + paper - spending
4. ...     print('В конце недели № %s будет %s рублей' % (week, savings))
5. ...
\end{verbatim}
\end{listing}

В строке 1 в переменную savings заносится начальное значение: 0 (ещё ничего не накопилось).

В строке 2 записан цикл \code{for}, который выполнится по разу для каждой из недель в году. На каждом шаге цикла переменная \code{week} будет иметь значение от 1 до 52\footnote{range(1,53) возвращает список чисел от 1 включительно до 53 не включительно, то есть [0,...,52].}.

В строке 3 к тому, что мы уже накопили, прибавляется ещё то, что накопится в очередную неделю. Иными словами, в переменную \code{savings} записывается столько, сколько там уже было, и ещё столько, сколько добавится на этой неделе. Знак равенства «\code{=}» говорит Питону посчитать всё, что справа от этого знака, и сохранить результат в переменную слева — и именно в таком порядке. Так что если и справа и слева от знака равенства есть одна и та же переменная, ничего страшного.

% TODO
% Вот оригинальный фрагмент текста, я не нашёл в себе силы перевести его более точно — welcome (clone, push, merge)
%Line 3 is a bit more complicated.  Basically, each week we want to add what we've saved to our total savings.  Think of the variable `savings' as something like a bank.  We add up the money we earn doing odd jobs and the paper route, subtract our spending money and then take the rest to the bank.  So in computer-speak, line 3 really means, ``replace the contents of the variable savings with my current savings, plus what I've earned this week''. Basically, the equals symbol (=) is a bossy piece of code that is a way of saying, ``work out some stuff on the right first and then save it for later, using the name on the left''.\\
В строке 4 печатается результат расчётов: сколько денег будет в конце каждой недели, считая с нынешней.
%TODO перевести ссылку:
%Check the section \emph{Tricks with Strings} on page~\pageref{trickswithstrings}, if this line doesn't make a lot of sense to you.

Если теперь запустить эту программу, получится вот что:

\begin{listing}
\begin{verbatim}
В конце недели № 1 будет 25 рублей
В конце недели № 2 будет 50 рублей
В конце недели № 3 будет 75 рублей
В конце недели № 4 будет 100 рублей
В конце недели № 5 будет 125 рублей
В конце недели № 6 будет 150 рублей
В конце недели № 7 будет 175 рублей
В конце недели № 8 будет 200 рублей
В конце недели № 9 будет 225 рублей
В конце недели № 10 будет 250 рублей
В конце недели № 11 будет 275 рублей
В конце недели № 12 будет 300 рублей
В конце недели № 13 будет 325 рублей
В конце недели № 14 будет 350 рублей
В конце недели № 15 будет 375 рублей
\end{verbatim}
\end{listing}

…и так далее до 52-й недели.


\section{Пока мы тут говорим про циклы…}\index{цикл while}

Циклом \code{for} в питоне дело не ограничивается. Есть ещё цикл \code{while} (что по-русски значит «пока» или «в то время как»). В Питоне для цикла \code{for} заранее известно, когда он остановится: когда переберёт все элементы (или раньше, если его прервать, но никак не позже). Цикл \code{while} используется в тех случаях, когда заранее непонятно, когда остановиться.

Представь себе освещённую лестницу из 20 ступенек. И представь, что по ней нужно подняться, печатая номер каждой очередной ступеньки\footnote{Между прочем, это уже вполне реальная ситуация. Когда роботов учат подниматься по лестнице, что даётся им непросто, после подъёма на каждую очередную ступеньку робот проверяет, что он не упал, и печатает номер ступеньки. Или понимает, что упал, и печатает номер ступеньки, на которой упал. Потом его программу улучшают так, чтобы он не падал.}. Если мы представим, что есть команда \code{step\_up()}, которую нужно вызвать, чтобы сделать шаг, то всё это можно записать таким циклом \code{for}:

\begin{listing}
\begin{verbatim}
>>> for step in range(0,20):
...     step_up()
...     print(step)
\end{verbatim}
\end{listing}

А теперь представь, что эта лестница не освещена; неизвестно, сколько в ней ступенек, а идти нужно до первой двери, а потом уйти в эту дверь с лестницы (и вообще, это длинная-длинная винтовая лестница в старинной магической башне). Тут не получится использовать цикл \code{for}, потому что наперёд неизвестно, сколько всего ступенек. Тут-то и нужен \code{while}:

\begin{verbatim}
>>> step = 0
>>> while no_door():
...     step_up()
...     print(step)
...     if tired():
...         break
...     else:
...         step = step + 1
>>> print('Остановились на ступеньке %s' % step)
\end{verbatim}

Этот код нет смысла запускать, потому что он использует выдуманные функции: \code{no\_door()}~— эта функция проверяет, есть ли дверь, и возвращает \code{True}, если её нет — и \code{tired()} — эта функция возвращает \code{True}, если сил идти вверх больше нет. Но этот код показывает смысл цикла \code{while}. Пока условие истинно, то есть пока \code{no\_door()} — правда, цикл выполняется. Внутри цикла мы проверяем, есть ли ещё силы идти вверх, и если нет, то тут же и прерываем цикл (\code{break}) и переходим к самой последней строчке кода. Потом, за циклом мы можем ещё раз проверить \code{no\_door}, чтобы понять, почему цикл завершился: надо ли войти в дверь или отдохнуть и идти дальше. Если же силы идти есть, то номер ступеньки увеличивается, и мы делаем следующий шаг.

Итак, цикл \code{while} устроен следующим образом:

{\renewcommand{\labelitemi}{$\triangleright$}
\begin{itemize}
\item проверить условие,
\item выполнить блок кода,
\item повторить всё с начала.
\end{itemize}}

Часто цикл \code{while} проверяет сразу несколько условий. Например, так:

\begin{listing}
\begin{verbatim}
>>> x = 45
>>> y = 80
>>> while x < 50 and y < 100:
...     x = x + 1
...     y = y + 1
...     print(x, y)
\end{verbatim}
\end{listing}

Тут есть две переменные и два условия, по одному для каждой. В цикле переменная \code{x} изменяется от 45 до 50, а \code{y} — от 80 до 100. Когда первая из переменных достигнет своего максимального значения (50 для \code{x} и 100 для \code{y}), цикл тут же завершится.

\begin{listing}
\begin{verbatim}
46 81
47 82
48 83
49 84
50 85
\end{verbatim}
\end{listing}

Наверное, не стоит тебе надоедать излишне подробными объяснениями, почему напечатались именно эти строки\footnote{…или всё-таки стоит? Вначале \code{x} равняется 45, а \code{y} — 80. Обе переменные увеличиваются на 1 на каждом шаге цикла и печатаются. Так и получается то, что напечатано. Когда \code{x} равно 50, условие \code{x < 50} перестаёт быть истинным (\code{True}), поэтому и всё вместе условие цикла «\code{x < 50 и y < 80}» тоже перестаёт быть истинным, и цикл завершается.}.

Ещё \code{while} используют, чтобы создать бесконечный цикл или почти бесконечный, вот так:

\begin{verbatim}
>>> while True:
...     lots of code here
...     lots of code here
...     lots of code here
...     if some_condition == True:
...         break
\end{verbatim}

Условие для этого цикла \code{while} — просто «\code{True}». Это условие всегда выполняется, и тело цикла всегда будет запускаться, это вечный цикл. Но как только переменная \code{some\_condition} тоже примет значение \code{True}, цикл прервётся инструкцией \code{break}.

Другой пример почти вечного цикла ты можешь подсмотреть в конце книги, в приложении \ref{app:afewpythonmodules} (там где про модуль \code{random}). А можешь подождать и сперва прочитать следующую главу, в которой как раз рассказывается про модули.

\section{Чем развлечься на досуге}

\btw{В этой главе мы увидели, как использовать циклы, чтобы выполнять повторяющиеся действия. Мы использовали блоки кода внутри циклов для записи этих действий.}

\subsection*{Упражнение 1}
Как ты думаешь, что произойдёт, если запустить этот код:

\begin{listing}
\begin{verbatim}
>>> for x in range(0, 20):
...     print('hello %s' % x)
...     if x < 9:
...         break
\end{verbatim}
\end{listing}

\subsection*{Упражнение 2}
Если положить деньги в банк, то банк за них платит проценты — за то, что он может ими пользоваться на своё усмотрение и давать кому-то в долг (под большие проценты). Каждый месяц банк добавляет на твой счёт какую-то небольшую часть от того, что на нём уже лежит. Например, если положить в банк 1000 рублей, то банк добавляет каждый месяц ещё по 10 рублей (сколько именно, зависит от банка, но примерно столько или меньше).

Так вот, когда ты кладёшь деньги в банк, он сообщает тебе, сколько \emph{процентов} в год банк добавит. Допустим, ты положил 1000 рублей, и банк добавит 5\% в год — тогда через год у тебя будет $1000 + 1000×0.05$ рублей. Если банк обещает добавить 10\%, то через год у тебя будет $1000+1000×0.10$ рублей — и так далее. Предположим, проценты выплачиваются в конце каждого года (хотя это и не так, но так проще считать и результаты получаются почти точные). Тогда, если ты положишь 1000 рублей под 7\% годовых, через год у тебя будет $1000+1000×0.07$. Потом ещё через год банк добавит 7\% уже на эту сумму. Ещё через год — на сумму, оставшуюся в конце второго года, — и так далее. В уме это посчитать сложно; а в жизни такая задача возникает часто.

Напиши программу, которая посчитает, сколько на счёте накопится денег через 10 лет, если положить 10 000 рублей под 15\% годовых (не забудь, что каждый год проценты считаются от той суммы, что лежала в конце прошлого года, а не той, что лежала в самом начале всех этих 10 лет).
\newpage